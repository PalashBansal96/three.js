// Generated by dts-bundle v0.7.3


export as namespace THREE_VECTOR;


/**
  * Defines a 2d shape plane using paths.
  */
export class Shape extends Path {

    constructor( points?: Vector2[] );

    /**
      * @default 'Shape'
      */
    type: string;

    /**
      * @default []
      */
    holes: Path[];

    getPointsHoles( divisions: number ): Vector2[][];

    extractPoints( divisions: number ): {
        shape: Vector2[];
        holes: Vector2[][];
    };

}


/**
  * a 2d path representation, comprising of points, lines, and cubes, similar to the html5 2d canvas api. It extends CurvePath.
  */
export class Path extends CurvePath<Vector2> {

    constructor( points?: Vector2[] );

    /**
      * @default 'Path'
      */
    type: string;

    /**
      * @default new THREE.Vector2()
      */
    currentPoint: Vector2;

    /**
      * @deprecated Use {@link Path#setFromPoints .setFromPoints()} instead.
      */
    fromPoints( vectors: Vector2[] ): this;
    setFromPoints( vectors: Vector2[] ): this;
    moveTo( x: number, y: number ): this;
    lineTo( x: number, y: number ): this;
    quadraticCurveTo( aCPx: number, aCPy: number, aX: number, aY: number ): this;
    bezierCurveTo(
        aCP1x: number,
        aCP1y: number,
        aCP2x: number,
        aCP2y: number,
        aX: number,
        aY: number
    ): this;
    splineThru( pts: Vector2[] ): this;
    arc(
        aX: number,
        aY: number,
        aRadius: number,
        aStartAngle: number,
        aEndAngle: number,
        aClockwise: boolean
    ): this;
    absarc(
        aX: number,
        aY: number,
        aRadius: number,
        aStartAngle: number,
        aEndAngle: number,
        aClockwise: boolean
    ): this;
    ellipse(
        aX: number,
        aY: number,
        xRadius: number,
        yRadius: number,
        aStartAngle: number,
        aEndAngle: number,
        aClockwise: boolean,
        aRotation: number
    ): this;
    absellipse(
        aX: number,
        aY: number,
        xRadius: number,
        yRadius: number,
        aStartAngle: number,
        aEndAngle: number,
        aClockwise: boolean,
        aRotation: number
    ): this;

}


export class ShapePath {

    constructor();

    /**
      * @default 'ShapePath'
      */
    type: string;

    /**
      * @default new THREE.Color()
      */
    color: Color;

    /**
      * @default []
      */
    subPaths: any[];

    /**
      * @default null
      */
    currentPath: any;

    moveTo( x: number, y: number ): this;
    lineTo( x: number, y: number ): this;
    quadraticCurveTo( aCPx: number, aCPy: number, aX: number, aY: number ): this;
    bezierCurveTo(
        aCP1x: number,
        aCP1y: number,
        aCP2x: number,
        aCP2y: number,
        aX: number,
        aY: number
    ): this;
    splineThru( pts: Vector2[] ): this;
    toShapes( isCCW: boolean, noHoles?: boolean ): Shape[];

}


export class Font {

    constructor( jsondata: any );

    /**
      * @default 'Font'
      */
    type: string;

    data: string;

    generateShapes( text: string, size: number ): Shape[];

}


export class CurvePath<T extends Vector> extends Curve<T> {

    constructor();

    /**
      * @default 'CurvePath'
      */
    type: string;

    /**
      * @default []
      */
    curves: Curve<T>[];

    /**
      * @default false
      */
    autoClose: boolean;

    add( curve: Curve<T> ): void;
    closePath(): void;
    getPoint( t: number ): T;
    getCurveLengths(): number[];

}



/**
  * An extensible curve object which contains methods for interpolation
  * class Curve<T extends Vector>
  */
export class Curve<T extends Vector> {

    /**
      * @default 'Curve'
      */
    type: string;

    /**
      * This value determines the amount of divisions when calculating the cumulative segment lengths of a curve via .getLengths.
      * To ensure precision when using methods like .getSpacedPoints, it is recommended to increase .arcLengthDivisions if the curve is very large.
      * @default 200
      */
    arcLengthDivisions: number;

    /**
      * Returns a vector for point t of the curve where t is between 0 and 1
      * getPoint(t: number, optionalTarget?: T): T;
      */
    getPoint( t: number, optionalTarget?: T ): T;

    /**
      * Returns a vector for point at relative position in curve according to arc length
      * getPointAt(u: number, optionalTarget?: T): T;
      */
    getPointAt( u: number, optionalTarget?: T ): T;

    /**
      * Get sequence of points using getPoint( t )
      * getPoints(divisions?: number): T[];
      */
    getPoints( divisions?: number ): T[];

    /**
      * Get sequence of equi-spaced points using getPointAt( u )
      * getSpacedPoints(divisions?: number): T[];
      */
    getSpacedPoints( divisions?: number ): T[];

    /**
      * Get total curve arc length
      */
    getLength(): number;

    /**
      * Get list of cumulative segment lengths
      */
    getLengths( divisions?: number ): number[];

    /**
      * Update the cumlative segment distance cache
      */
    updateArcLengths(): void;

    /**
      * Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance
      */
    getUtoTmapping( u: number, distance: number ): number;

    /**
      * Returns a unit vector tangent at t. If the subclassed curve do not implement its tangent derivation, 2 points a small delta apart will be used to find its gradient which seems to give a reasonable approximation
      * getTangent(t: number, optionalTarget?: T): T;
      */
    getTangent( t: number, optionalTarget?: T ): T;

    /**
      * Returns tangent at equidistance point u on the curve
      * getTangentAt(u: number, optionalTarget?: T): T;
      */
    getTangentAt( u: number, optionalTarget?: T ): T;

    clone(): Curve<T>;
    copy( source: Curve<T> ): this;
    toJSON(): object;
    fromJSON( json: object ): this;

    /**
      * @deprecated since r84.
      */
    static create( constructorFunc: Function, getPointFunc: Function ): Function;

}

interface Vec2 {
    x: number;
    y: number;
}

export namespace ShapeUtils {
    export function area( contour: Vec2[] ): number;
    export function triangulateShape( contour: Vec2[], holes: Vec2[][] ): number[][];
    export function isClockWise( pts: Vec2[] ): boolean;
}

export class ArcCurve extends EllipseCurve {

    constructor(
        aX: number,
        aY: number,
        aRadius: number,
        aStartAngle: number,
        aEndAngle: number,
        aClockwise: boolean
    );

    /**
      * @default 'ArcCurve'
      */
    type: string;

}


export namespace CurveUtils {
    export function tangentQuadraticBezier(
        t: number,
        p0: number,
        p1: number,
        p2: number
    ): number;
    export function tangentCubicBezier(
        t: number,
        p0: number,
        p1: number,
        p2: number,
        p3: number
    ): number;
    export function tangentSpline(
        t: number,
        p0: number,
        p1: number,
        p2: number,
        p3: number
    ): number;
    export function interpolate(
        p0: number,
        p1: number,
        p2: number,
        p3: number,
        t: number
    ): number;
}

export class CatmullRomCurve3 extends Curve<Vector3> {

    /**
      * @param [points=[]]
      * @param [closed=false]
      * @param [curveType='centripetal']
      * @param [tension=0.5]
      */
    constructor(
        points?: Vector3[],
        closed?: boolean,
        curveType?: string,
        tension?: number
    );

    /**
      * @default 'CatmullRomCurve3'
      */
    type: string;

    /**
      * @default []
      */
    points: Vector3[];

}


export class CubicBezierCurve extends Curve<Vector2> {

    constructor( v0: Vector2, v1: Vector2, v2: Vector2, v3: Vector2 );

    /**
      * @default 'CubicBezierCurve'
      */
    type: string;

    /**
      * @default new THREE.Vector2()
      */
    v0: Vector2;

    /**
      * @default new THREE.Vector2()
      */
    v1: Vector2;

    /**
      * @default new THREE.Vector2()
      */
    v2: Vector2;

    /**
      * @default new THREE.Vector2()
      */
    v3: Vector2;

}


export class CubicBezierCurve3 extends Curve<Vector3> {

    constructor( v0: Vector3, v1: Vector3, v2: Vector3, v3: Vector3 );

    /**
      * @default 'CubicBezierCurve3'
      */
    type: string;

    /**
      * @default new THREE.Vector3()
      */
    v0: Vector3;

    /**
      * @default new THREE.Vector3()
      */
    v1: Vector3;

    /**
      * @default new THREE.Vector3()
      */
    v2: Vector3;

    /**
      * @default new THREE.Vector3()
      */
    v3: Vector3;

}


export class EllipseCurve extends Curve<Vector2> {

    constructor(
        aX: number,
        aY: number,
        xRadius: number,
        yRadius: number,
        aStartAngle: number,
        aEndAngle: number,
        aClockwise: boolean,
        aRotation: number
    );

    /**
      * @default 'EllipseCurve'
      */
    type: string;

    /**
      * @default 0
      */
    aX: number;

    /**
      * @default 0
      */
    aY: number;

    /**
      * @default 1
      */
    xRadius: number;

    /**
      * @default 1
      */
    yRadius: number;

    /**
      * @default 0
      */
    aStartAngle: number;

    /**
      * @default 2 * Math.PI
      */
    aEndAngle: number;

    /**
      * @default false
      */
    aClockwise: boolean;

    /**
      * @default 0
      */
    aRotation: number;

}


export class LineCurve extends Curve<Vector2> {

    constructor( v1: Vector2, v2: Vector2 );

    /**
      * @default 'LineCurve'
      */
    type: string;


    /**
      * @default new THREE.Vector2()
      */
    v1: Vector2;

    /**
      * @default new THREE.Vector2()
      */
    v2: Vector2;

}


export class LineCurve3 extends Curve<Vector3> {

    constructor( v1: Vector3, v2: Vector3 );

    /**
      * @default 'LineCurve3'
      */
    type: string;


    /**
      * @default new THREE.Vector3()
      */
    v1: Vector3;

    /**
      * @default new THREE.Vector3()
      */
    v2: Vector3;

}


export class QuadraticBezierCurve extends Curve<Vector2> {

    constructor( v0: Vector2, v1: Vector2, v2: Vector2 );

    /**
      * @default 'QuadraticBezierCurve'
      */
    type: string;

    /**
      * @default new THREE.Vector2()
      */
    v0: Vector2;

    /**
      * @default new THREE.Vector2()
      */
    v1: Vector2;

    /**
      * @default new THREE.Vector2()
      */
    v2: Vector2;

}


export class QuadraticBezierCurve3 extends Curve<Vector3> {

    constructor( v0: Vector3, v1: Vector3, v2: Vector3 );

    /**
      * @default 'QuadraticBezierCurve3'
      */
    type: string;

    /**
      * @default new THREE.Vector3()
      */
    v0: Vector3;

    /**
      * @default new THREE.Vector3()
      */
    v1: Vector3;

    /**
      * @default new THREE.Vector3()
      */
    v2: Vector3;

}


export class SplineCurve extends Curve<Vector2> {

    constructor( points?: Vector2[] );

    /**
      * @default 'SplineCurve'
      */
    type: string;

    /**
      * @default []
      */
    points: Vector2[];

}


/**
  * ( interface Vector<T> )
  *
  * Abstract interface of {@link https://github.com/mrdoob/three.js/blob/master/src/math/Vector2.js|Vector2},
  * {@link https://github.com/mrdoob/three.js/blob/master/src/math/Vector3.js|Vector3}
  * and {@link https://github.com/mrdoob/three.js/blob/master/src/math/Vector4.js|Vector4}.
  *
  * Currently the members of Vector is NOT type safe because it accepts different typed vectors.
  *
  * Those definitions will be changed when TypeScript innovates Generics to be type safe.
  *
  * @example
  * const v:THREE.Vector = new THREE.Vector3();
  * v.addVectors(new THREE.Vector2(0, 1), new THREE.Vector2(2, 3)); // invalid but compiled successfully
  */
export interface Vector {
    setComponent( index: number, value: number ): this;

    getComponent( index: number ): number;

    set( ...args: number[] ): this;

    setScalar( scalar: number ): this;

    /**
      * copy(v:T):T;
      */
    copy( v: Vector ): this;

    /**
      * NOTE: The second argument is deprecated.
      *
      * add(v:T):T;
      */
    add( v: Vector ): this;

    /**
      * addVectors(a:T, b:T):T;
      */
    addVectors( a: Vector, b: Vector ): this;

    addScaledVector( vector: Vector, scale: number ): this;

    /**
      * Adds the scalar value s to this vector's values.
      */
    addScalar( scalar: number ): this;

    /**
      * sub(v:T):T;
      */
    sub( v: Vector ): this;

    /**
      * subVectors(a:T, b:T):T;
      */
    subVectors( a: Vector, b: Vector ): this;

    /**
      * multiplyScalar(s:number):T;
      */
    multiplyScalar( s: number ): this;

    /**
      * divideScalar(s:number):T;
      */
    divideScalar( s: number ): this;

    /**
      * negate():T;
      */
    negate(): this;

    /**
      * dot(v:T):T;
      */
    dot( v: Vector ): number;

    /**
      * lengthSq():number;
      */
    lengthSq(): number;

    /**
      * length():number;
      */
    length(): number;

    /**
      * normalize():T;
      */
    normalize(): this;

    /**
      * NOTE: Vector4 doesn't have the property.
      *
      * distanceTo(v:T):number;
      */
    distanceTo?( v: Vector ): number;

    /**
      * NOTE: Vector4 doesn't have the property.
      *
      * distanceToSquared(v:T):number;
      */
    distanceToSquared?( v: Vector ): number;

    /**
      * setLength(l:number):T;
      */
    setLength( l: number ): this;

    /**
      * lerp(v:T, alpha:number):T;
      */
    lerp( v: Vector, alpha: number ): this;

    /**
      * equals(v:T):boolean;
      */
    equals( v: Vector ): boolean;

    /**
      * clone():T;
      */
    clone(): this;
}

/**
  * 2D vector.
  *
  * ( class Vector2 implements Vector<Vector2> )
  */
export class Vector2 implements Vector {

    constructor( x?: number, y?: number );

    /**
      * @default 0
      */
    x: number;

    /**
      * @default 0
      */
    y: number;
    width: number;
    height: number;
    readonly isVector2: true;

    /**
      * Sets value of this vector.
      */
    set( x: number, y: number ): this;

    /**
      * Sets the x and y values of this vector both equal to scalar.
      */
    setScalar( scalar: number ): this;

    /**
      * Sets X component of this vector.
      */
    setX( x: number ): this;

    /**
      * Sets Y component of this vector.
      */
    setY( y: number ): this;

    /**
      * Sets a component of this vector.
      */
    setComponent( index: number, value: number ): this;

    /**
      * Gets a component of this vector.
      */
    getComponent( index: number ): number;

    /**
      * Returns a new Vector2 instance with the same `x` and `y` values.
      */
    clone(): this;

    /**
      * Copies value of v to this vector.
      */
    copy( v: Vector2 ): this;

    /**
      * Adds v to this vector.
      */
    add( v: Vector2, w?: Vector2 ): this;

    /**
      * Adds the scalar value s to this vector's x and y values.
      */
    addScalar( s: number ): this;

    /**
      * Sets this vector to a + b.
      */
    addVectors( a: Vector2, b: Vector2 ): this;

    /**
      * Adds the multiple of v and s to this vector.
      */
    addScaledVector( v: Vector2, s: number ): this;

    /**
      * Subtracts v from this vector.
      */
    sub( v: Vector2 ): this;

    /**
      * Subtracts s from this vector's x and y components.
      */
    subScalar( s: number ): this;

    /**
      * Sets this vector to a - b.
      */
    subVectors( a: Vector2, b: Vector2 ): this;

    /**
      * Multiplies this vector by v.
      */
    multiply( v: Vector2 ): this;

    /**
      * Multiplies this vector by scalar s.
      */
    multiplyScalar( scalar: number ): this;

    /**
      * Divides this vector by v.
      */
    divide( v: Vector2 ): this;

    /**
      * Divides this vector by scalar s.
      * Set vector to ( 0, 0 ) if s == 0.
      */
    divideScalar( s: number ): this;

    /**
      * Multiplies this vector (with an implicit 1 as the 3rd component) by m.
      */
    applyMatrix3( m: Matrix3 ): this;

    /**
      * If this vector's x or y value is greater than v's x or y value, replace that value with the corresponding min value.
      */
    min( v: Vector2 ): this;

    /**
      * If this vector's x or y value is less than v's x or y value, replace that value with the corresponding max value.
      */
    max( v: Vector2 ): this;

    /**
      * If this vector's x or y value is greater than the max vector's x or y value, it is replaced by the corresponding value.
      * If this vector's x or y value is less than the min vector's x or y value, it is replaced by the corresponding value.
      * @param min the minimum x and y values.
      * @param max the maximum x and y values in the desired range.
      */
    clamp( min: Vector2, max: Vector2 ): this;

    /**
      * If this vector's x or y values are greater than the max value, they are replaced by the max value.
      * If this vector's x or y values are less than the min value, they are replaced by the min value.
      * @param min the minimum value the components will be clamped to.
      * @param max the maximum value the components will be clamped to.
      */
    clampScalar( min: number, max: number ): this;

    /**
      * If this vector's length is greater than the max value, it is replaced by the max value.
      * If this vector's length is less than the min value, it is replaced by the min value.
      * @param min the minimum value the length will be clamped to.
      * @param max the maximum value the length will be clamped to.
      */
    clampLength( min: number, max: number ): this;

    /**
      * The components of the vector are rounded down to the nearest integer value.
      */
    floor(): this;

    /**
      * The x and y components of the vector are rounded up to the nearest integer value.
      */
    ceil(): this;

    /**
      * The components of the vector are rounded to the nearest integer value.
      */
    round(): this;

    /**
      * The components of the vector are rounded towards zero (up if negative, down if positive) to an integer value.
      */
    roundToZero(): this;

    /**
      * Inverts this vector.
      */
    negate(): this;

    /**
      * Computes dot product of this vector and v.
      */
    dot( v: Vector2 ): number;

    /**
      * Computes cross product of this vector and v.
      */
    cross( v: Vector2 ): number;

    /**
      * Computes squared length of this vector.
      */
    lengthSq(): number;

    /**
      * Computes length of this vector.
      */
    length(): number;

    /**
      * @deprecated Use {@link Vector2#manhattanLength .manhattanLength()} instead.
      */
    lengthManhattan(): number;

    /**
      * Computes the Manhattan length of this vector.
      *
      * @return {number}
      *
      * @see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
      */
    manhattanLength(): number;

    /**
      * Normalizes this vector.
      */
    normalize(): this;

    /**
      * computes the angle in radians with respect to the positive x-axis
      */
    angle(): number;

    /**
      * Computes distance of this vector to v.
      */
    distanceTo( v: Vector2 ): number;

    /**
      * Computes squared distance of this vector to v.
      */
    distanceToSquared( v: Vector2 ): number;

    /**
      * @deprecated Use {@link Vector2#manhattanDistanceTo .manhattanDistanceTo()} instead.
      */
    distanceToManhattan( v: Vector2 ): number;

    /**
      * Computes the Manhattan length (distance) from this vector to the given vector v
      *
      * @param {Vector2} v
      *
      * @return {number}
      *
      * @see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
      */
    manhattanDistanceTo( v: Vector2 ): number;

    /**
      * Normalizes this vector and multiplies it by l.
      */
    setLength( length: number ): this;

    /**
      * Linearly interpolates between this vector and v, where alpha is the distance along the line - alpha = 0 will be this vector, and alpha = 1 will be v.
      * @param v vector to interpolate towards.
      * @param alpha interpolation factor in the closed interval [0, 1].
      */
    lerp( v: Vector2, alpha: number ): this;

    /**
      * Sets this vector to be the vector linearly interpolated between v1 and v2 where alpha is the distance along the line connecting the two vectors - alpha = 0 will be v1, and alpha = 1 will be v2.
      * @param v1 the starting vector.
      * @param v2 vector to interpolate towards.
      * @param alpha interpolation factor in the closed interval [0, 1].
      */
    lerpVectors( v1: Vector2, v2: Vector2, alpha: number ): this;

    /**
      * Checks for strict equality of this vector and v.
      */
    equals( v: Vector2 ): boolean;

    /**
      * Sets this vector's x and y value from the provided array.
      * @param array the source array.
      * @param offset (optional) offset into the array. Default is 0.
      */
    fromArray( array: number[], offset?: number ): this;

    /**
      * Sets this vector's x and y value from the provided array-like.
      * @param array the source array-like.
      * @param offset (optional) offset into the array-like. Default is 0.
      */
    fromArray( array: ArrayLike<number>, offset?: number ): this;

    /**
      * Returns an array [x, y], or copies x and y into the provided array.
      * @param array (optional) array to store the vector to. If this is not provided, a new array will be created.
      * @param offset (optional) optional offset into the array.
      * @return The created or provided array.
      */
    toArray( array?: number[], offset?: number ): number[];

    /**
      * Copies x and y into the provided array-like.
      * @param array array-like to store the vector to.
      * @param offset (optional) optional offset into the array.
      * @return The provided array-like.
      */
    toArray( array: ArrayLike<number>, offset?: number ): ArrayLike<number>;

    /**
      * Sets this vector's x and y values from the attribute.
      * @param attribute the source attribute.
      * @param index index in the attribute.
      */
    fromBufferAttribute( attribute: any, index: number ): this; //#added vector lib
    // fromBufferAttribute( attribute: BufferAttribute, index: number ): this;

    /**
      * Rotates the vector around center by angle radians.
      * @param center the point around which to rotate.
      * @param angle the angle to rotate, in radians.
      */
    rotateAround( center: Vector2, angle: number ): this;

    /**
      * Sets this vector's x and y from Math.random
      */
    random(): this;

}


export interface HSL {
    h: number;
    s: number;
    l: number;
}

/**
  * Represents a color. See also {@link ColorUtils}.
  *
  * @example
  * const color = new THREE.Color( 0xff0000 );
  *
  * @see {@link https://github.com/mrdoob/three.js/blob/master/src/math/Color.js|src/math/Color.js}
  */
export class Color {

    constructor( color?: Color | string | number );
    constructor( r: number, g: number, b: number );

    readonly isColor: true;

    /**
      * Red channel value between 0 and 1. Default is 1.
      * @default 1
      */
    r: number;

    /**
      * Green channel value between 0 and 1. Default is 1.
      * @default 1
      */
    g: number;

    /**
      * Blue channel value between 0 and 1. Default is 1.
      * @default 1
      */
    b: number;

    set( color: Color | string | number ): Color;
    setScalar( scalar: number ): Color;
    setHex( hex: number ): Color;

    /**
      * Sets this color from RGB values.
      * @param r Red channel value between 0 and 1.
      * @param g Green channel value between 0 and 1.
      * @param b Blue channel value between 0 and 1.
      */
    setRGB( r: number, g: number, b: number ): Color;

    /**
      * Sets this color from HSL values.
      * Based on MochiKit implementation by Bob Ippolito.
      *
      * @param h Hue channel value between 0 and 1.
      * @param s Saturation value channel between 0 and 1.
      * @param l Value channel value between 0 and 1.
      */
    setHSL( h: number, s: number, l: number ): Color;

    /**
      * Sets this color from a CSS context style string.
      * @param contextStyle Color in CSS context style format.
      */
    setStyle( style: string ): Color;

    /**
      * Sets this color from a color name.
      * Faster than {@link Color#setStyle .setStyle()} method if you don't need the other CSS-style formats.
      * @param style Color name in X11 format.
      */
    setColorName( style: string ): Color;

    /**
      * Clones this color.
      */
    clone(): this;

    /**
      * Copies given color.
      * @param color Color to copy.
      */
    copy( color: Color ): this;

    /**
      * Copies given color making conversion from gamma to linear space.
      * @param color Color to copy.
      */
    copyGammaToLinear( color: Color, gammaFactor?: number ): Color;

    /**
      * Copies given color making conversion from linear to gamma space.
      * @param color Color to copy.
      */
    copyLinearToGamma( color: Color, gammaFactor?: number ): Color;

    /**
      * Converts this color from gamma to linear space.
      */
    convertGammaToLinear( gammaFactor?: number ): Color;

    /**
      * Converts this color from linear to gamma space.
      */
    convertLinearToGamma( gammaFactor?: number ): Color;

    /**
      * Copies given color making conversion from sRGB to linear space.
      * @param color Color to copy.
      */
    copySRGBToLinear( color: Color ): Color;

    /**
      * Copies given color making conversion from linear to sRGB space.
      * @param color Color to copy.
      */
    copyLinearToSRGB( color: Color ): Color;

    /**
      * Converts this color from sRGB to linear space.
      */
    convertSRGBToLinear(): Color;

    /**
      * Converts this color from linear to sRGB space.
      */
    convertLinearToSRGB(): Color;

    /**
      * Returns the hexadecimal value of this color.
      */
    getHex(): number;

    /**
      * Returns the string formated hexadecimal value of this color.
      */
    getHexString(): string;

    getHSL( target: HSL ): HSL;

    /**
      * Returns the value of this color in CSS context style.
      * Example: rgb(r, g, b)
      */
    getStyle(): string;

    offsetHSL( h: number, s: number, l: number ): this;

    add( color: Color ): this;
    addColors( color1: Color, color2: Color ): this;
    addScalar( s: number ): this;
    sub( color: Color ): this;
    multiply( color: Color ): this;
    multiplyScalar( s: number ): this;
    lerp( color: Color, alpha: number ): this;
    lerpHSL( color: Color, alpha: number ): this;
    equals( color: Color ): boolean;

    /**
      * Sets this color's red, green and blue value from the provided array.
      * @param array the source array.
      * @param offset (optional) offset into the array. Default is 0.
      */
    fromArray( array: number[], offset?: number ): this;

    /**
      * Sets this color's red, green and blue value from the provided array-like.
      * @param array the source array-like.
      * @param offset (optional) offset into the array-like. Default is 0.
      */
    fromArray( array: ArrayLike<number>, offset?: number ): this;

    /**
      * Returns an array [red, green, blue], or copies red, green and blue into the provided array.
      * @param array (optional) array to store the color to. If this is not provided, a new array will be created.
      * @param offset (optional) optional offset into the array.
      * @return The created or provided array.
      */
    toArray( array?: number[], offset?: number ): number[];

    /**
      * Copies red, green and blue into the provided array-like.
      * @param array array-like to store the color to.
      * @param offset (optional) optional offset into the array-like.
      * @return The provided array-like.
      */
    toArray( xyz: ArrayLike<number>, offset?: number ): ArrayLike<number>;

    // fromBufferAttribute( attribute: BufferAttribute, index: number ): this;
    fromBufferAttribute( attribute: any, index: number ): this; //#added vector lib

    /**
      * List of X11 color names.
      */
    static NAMES: Record<string, number>;

}

/**
  * 3D vector.
  *
  * @example
  * const a = new THREE.Vector3( 1, 0, 0 );
  * const b = new THREE.Vector3( 0, 1, 0 );
  * const c = new THREE.Vector3();
  * c.crossVectors( a, b );
  *
  * @see {@link https://github.com/mrdoob/three.js/blob/master/src/math/Vector3.js|src/math/Vector3.js}
  *
  * ( class Vector3 implements Vector<Vector3> )
  */
export class Vector3 implements Vector {

    constructor( x?: number, y?: number, z?: number );

    /**
      * @default 0
      */
    x: number;

    /**
      * @default 0
      */
    y: number;

    /**
      * @default 0
      */
    z: number;
    readonly isVector3: true;

    /**
      * Sets value of this vector.
      */
    set( x: number, y: number, z: number ): this;

    /**
      * Sets all values of this vector.
      */
    setScalar( scalar: number ): this;

    /**
      * Sets x value of this vector.
      */
    setX( x: number ): Vector3;

    /**
      * Sets y value of this vector.
      */
    setY( y: number ): Vector3;

    /**
      * Sets z value of this vector.
      */
    setZ( z: number ): Vector3;

    setComponent( index: number, value: number ): this;

    getComponent( index: number ): number;

    /**
      * Clones this vector.
      */
    clone(): this;

    /**
      * Copies value of v to this vector.
      */
    copy( v: Vector3 ): this;

    /**
      * Adds v to this vector.
      */
    add( v: Vector3 ): this;

    addScalar( s: number ): this;

    addScaledVector( v: Vector3, s: number ): this;

    /**
      * Sets this vector to a + b.
      */
    addVectors( a: Vector3, b: Vector3 ): this;

    /**
      * Subtracts v from this vector.
      */
    sub( a: Vector3 ): this;

    subScalar( s: number ): this;

    /**
      * Sets this vector to a - b.
      */
    subVectors( a: Vector3, b: Vector3 ): this;

    multiply( v: Vector3 ): this;

    /**
      * Multiplies this vector by scalar s.
      */
    multiplyScalar( s: number ): this;

    multiplyVectors( a: Vector3, b: Vector3 ): this;

    applyEuler( euler: Euler ): this;

    applyAxisAngle( axis: Vector3, angle: number ): this;

    applyMatrix3( m: Matrix3 ): this;

    applyNormalMatrix( m: Matrix3 ): this;

    applyMatrix4( m: Matrix4 ): this;

    applyQuaternion( q: Quaternion ): this;

    // project( camera: Camera ): this;
    //
    // unproject( camera: Camera ): this;

    project( camera: any ): this;  //#added vector lib

    unproject( camera: any ): this;  //#added vector lib

    transformDirection( m: Matrix4 ): this;

    divide( v: Vector3 ): this;

    /**
      * Divides this vector by scalar s.
      * Set vector to ( 0, 0, 0 ) if s == 0.
      */
    divideScalar( s: number ): this;

    min( v: Vector3 ): this;

    max( v: Vector3 ): this;

    clamp( min: Vector3, max: Vector3 ): this;

    clampScalar( min: number, max: number ): this;

    clampLength( min: number, max: number ): this;

    floor(): this;

    ceil(): this;

    round(): this;

    roundToZero(): this;

    /**
      * Inverts this vector.
      */
    negate(): this;

    /**
      * Computes dot product of this vector and v.
      */
    dot( v: Vector3 ): number;

    /**
      * Computes squared length of this vector.
      */
    lengthSq(): number;

    /**
      * Computes length of this vector.
      */
    length(): number;

    /**
      * Computes Manhattan length of this vector.
      * http://en.wikipedia.org/wiki/Taxicab_geometry
      *
      * @deprecated Use {@link Vector3#manhattanLength .manhattanLength()} instead.
      */
    lengthManhattan(): number;

    /**
      * Computes the Manhattan length of this vector.
      *
      * @return {number}
      *
      * @see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
      */
    manhattanLength(): number;

    /**
      * Computes the Manhattan length (distance) from this vector to the given vector v
      *
      * @param {Vector3} v
      *
      * @return {number}
      *
      * @see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}
      */
    manhattanDistanceTo( v: Vector3 ): number;

    /**
      * Normalizes this vector.
      */
    normalize(): this;

    /**
      * Normalizes this vector and multiplies it by l.
      */
    setLength( l: number ): this;
    lerp( v: Vector3, alpha: number ): this;

    lerpVectors( v1: Vector3, v2: Vector3, alpha: number ): this;

    /**
      * Sets this vector to cross product of itself and v.
      */
    cross( a: Vector3 ): this;

    /**
      * Sets this vector to cross product of a and b.
      */
    crossVectors( a: Vector3, b: Vector3 ): this;
    projectOnVector( v: Vector3 ): this;
    projectOnPlane( planeNormal: Vector3 ): this;
    reflect( vector: Vector3 ): this;
    angleTo( v: Vector3 ): number;

    /**
      * Computes distance of this vector to v.
      */
    distanceTo( v: Vector3 ): number;

    /**
      * Computes squared distance of this vector to v.
      */
    distanceToSquared( v: Vector3 ): number;

    /**
      * @deprecated Use {@link Vector3#manhattanDistanceTo .manhattanDistanceTo()} instead.
      */
    distanceToManhattan( v: Vector3 ): number;

    setFromSpherical( s: Spherical ): this;
    setFromSphericalCoords( r: number, phi: number, theta:number ): this;
    setFromCylindrical( s: Cylindrical ): this;
    setFromCylindricalCoords( radius: number, theta: number, y: number ): this;
    setFromMatrixPosition( m: Matrix4 ): this;
    setFromMatrixScale( m: Matrix4 ): this;
    setFromMatrixColumn( matrix: Matrix4, index: number ): this;
    setFromMatrix3Column( matrix: Matrix3, index: number ): this;

    /**
      * Checks for strict equality of this vector and v.
      */
    equals( v: Vector3 ): boolean;

    /**
      * Sets this vector's x, y and z value from the provided array.
      * @param array the source array.
      * @param offset (optional) offset into the array. Default is 0.
      */
    fromArray( array: number[], offset?: number ): this;

    /**
      * Sets this vector's x, y and z value from the provided array-like.
      * @param array the source array-like.
      * @param offset (optional) offset into the array-like. Default is 0.
      */
    fromArray( array: ArrayLike<number>, offset?: number ): this;

    /**
      * Returns an array [x, y, z], or copies x, y and z into the provided array.
      * @param array (optional) array to store the vector to. If this is not provided, a new array will be created.
      * @param offset (optional) optional offset into the array.
      * @return The created or provided array.
      */
    toArray( array?: number[], offset?: number ): number[];

    /**
      * Copies x, y and z into the provided array-like.
      * @param array array-like to store the vector to.
      * @param offset (optional) optional offset into the array-like.
      * @return The provided array-like.
      */
    toArray( array: ArrayLike<number>, offset?: number ): ArrayLike<number>;

    // fromBufferAttribute(
    // 	attribute: BufferAttribute | InterleavedBufferAttribute,
    // 	index: number
    // ): this;

    fromBufferAttribute(
        attribute: any,
        index: number
    ): this; //#added vector lib

    /**
      * Sets this vector's x, y and z from Math.random
      */
    random(): this;

}


/**
  * ( interface Matrix<T> )
  */
export interface Matrix {
    /**
      * Array with matrix values.
      */
    elements: number[];

    /**
      * identity():T;
      */
    identity(): Matrix;

    /**
      * copy(m:T):T;
      */
    copy( m: this ): this;

    /**
      * multiplyScalar(s:number):T;
      */
    multiplyScalar( s: number ): Matrix;

    determinant(): number;

    /**
      * getInverse(matrix:T):T;
      */
    getInverse( matrix: Matrix ): Matrix;

    /**
      * transpose():T;
      */
    transpose(): Matrix;

    /**
      * clone():T;
      */
    clone(): this;
}

/**
  * ( class Matrix3 implements Matrix<Matrix3> )
  */
export class Matrix3 implements Matrix {

    /**
      * Creates an identity matrix.
      */
    constructor();

    /**
      * Array with matrix values.
      * @default [1, 0, 0, 0, 1, 0, 0, 0, 1]
      */
    elements: number[];

    set(
        n11: number,
        n12: number,
        n13: number,
        n21: number,
        n22: number,
        n23: number,
        n31: number,
        n32: number,
        n33: number
    ): Matrix3;
    identity(): Matrix3;
    clone(): this;
    copy( m: Matrix3 ): this;
    extractBasis( xAxis: Vector3, yAxis: Vector3, zAxis: Vector3 ): Matrix3;
    setFromMatrix4( m: Matrix4 ): Matrix3;
    multiplyScalar( s: number ): Matrix3;
    determinant(): number;
    getInverse( matrix: Matrix3 ): Matrix3;

    /**
      * Transposes this matrix in place.
      */
    transpose(): Matrix3;
    getNormalMatrix( matrix4: Matrix4 ): Matrix3;

    /**
      * Transposes this matrix into the supplied array r, and returns itself.
      */
    transposeIntoArray( r: number[] ): Matrix3;

    setUvTransform( tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number ): Matrix3;

    scale( sx: number, sy: number ): Matrix3;

    rotate( theta: number ): Matrix3;

    translate( tx: number, ty: number ): Matrix3;

    equals( matrix: Matrix3 ): boolean;

    /**
      * Sets the values of this matrix from the provided array.
      * @param array the source array.
      * @param offset (optional) offset into the array. Default is 0.
      */
    fromArray( array: number[], offset?: number ): Matrix3;

    /**
      * Sets the values of this matrix from the provided array-like.
      * @param array the source array-like.
      * @param offset (optional) offset into the array-like. Default is 0.
      */
    fromArray( array: ArrayLike<number>, offset?: number ): Matrix3;

    /**
      * Returns an array with the values of this matrix, or copies them into the provided array.
      * @param array (optional) array to store the matrix to. If this is not provided, a new array will be created.
      * @param offset (optional) optional offset into the array.
      * @return The created or provided array.
      */
    toArray( array?: number[], offset?: number ): number[];

    /**
      * Copies he values of this matrix into the provided array-like.
      * @param array array-like to store the matrix to.
      * @param offset (optional) optional offset into the array-like.
      * @return The provided array-like.
      */
    toArray( array?: ArrayLike<number>, offset?: number ): ArrayLike<number>;

    /**
      * Multiplies this matrix by m.
      */
    multiply( m: Matrix3 ): Matrix3;

    premultiply( m: Matrix3 ): Matrix3;

    /**
      * Sets this matrix to a x b.
      */
    multiplyMatrices( a: Matrix3, b: Matrix3 ): Matrix3;

    /**
      * @deprecated Use {@link Vector3.applyMatrix3 vector.applyMatrix3( matrix )} instead.
      */
    multiplyVector3( vector: Vector3 ): any;

    /**
      * @deprecated This method has been removed completely.
      */
    multiplyVector3Array( a: any ): any;
    getInverse( matrix: Matrix4, throwOnDegenerate?: boolean ): Matrix3;

    /**
      * @deprecated Use {@link Matrix3#toArray .toArray()} instead.
      */
    flattenToArrayOffset( array: number[], offset: number ): number[];

}


export class Euler {

    constructor( x?: number, y?: number, z?: number, order?: string );

    /**
      * @default 0
      */
    x: number;

    /**
      * @default 0
      */
    y: number;

    /**
      * @default 0
      */
    z: number;

    /**
      * @default THREE.Euler.DefaultOrder
      */
    order: string;
    readonly isEuler: true;

    _onChangeCallback: Function;

    set( x: number, y: number, z: number, order?: string ): Euler;
    clone(): this;
    copy( euler: Euler ): this;
    setFromRotationMatrix( m: Matrix4, order?: string ): Euler;
    setFromQuaternion( q: Quaternion, order?: string ): Euler;
    setFromVector3( v: Vector3, order?: string ): Euler;
    reorder( newOrder: string ): Euler;
    equals( euler: Euler ): boolean;
    fromArray( xyzo: any[] ): Euler;
    toArray( array?: number[], offset?: number ): number[];
    toVector3( optionalResult?: Vector3 ): Vector3;
    _onChange( callback: Function ): this;

    static RotationOrders: string[];
    static DefaultOrder: string;

}

/**
  * A 4x4 Matrix.
  *
  * @example
  * // Simple rig for rotating around 3 axes
  * const m = new THREE.Matrix4();
  * const m1 = new THREE.Matrix4();
  * const m2 = new THREE.Matrix4();
  * const m3 = new THREE.Matrix4();
  * const alpha = 0;
  * const beta = Math.PI;
  * const gamma = Math.PI/2;
  * m1.makeRotationX( alpha );
  * m2.makeRotationY( beta );
  * m3.makeRotationZ( gamma );
  * m.multiplyMatrices( m1, m2 );
  * m.multiply( m3 );
  */
export class Matrix4 implements Matrix {

    constructor();

    /**
      * Array with matrix values.
      * @default [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
      */
    elements: number[];

    /**
      * Sets all fields of this matrix.
      */
    set(
        n11: number,
        n12: number,
        n13: number,
        n14: number,
        n21: number,
        n22: number,
        n23: number,
        n24: number,
        n31: number,
        n32: number,
        n33: number,
        n34: number,
        n41: number,
        n42: number,
        n43: number,
        n44: number
    ): Matrix4;

    /**
      * Resets this matrix to identity.
      */
    identity(): Matrix4;
    clone(): this;
    copy( m: Matrix4 ): this;
    copyPosition( m: Matrix4 ): Matrix4;
    extractBasis( xAxis: Vector3, yAxis: Vector3, zAxis: Vector3 ): Matrix4;
    makeBasis( xAxis: Vector3, yAxis: Vector3, zAxis: Vector3 ): Matrix4;

    /**
      * Copies the rotation component of the supplied matrix m into this matrix rotation component.
      */
    extractRotation( m: Matrix4 ): Matrix4;
    makeRotationFromEuler( euler: Euler ): Matrix4;
    makeRotationFromQuaternion( q: Quaternion ): Matrix4;
    /**
      * Constructs a rotation matrix, looking from eye towards center with defined up vector.
      */
    lookAt( eye: Vector3, target: Vector3, up: Vector3 ): Matrix4;

    /**
      * Multiplies this matrix by m.
      */
    multiply( m: Matrix4 ): Matrix4;

    premultiply( m: Matrix4 ): Matrix4;

    /**
      * Sets this matrix to a x b.
      */
    multiplyMatrices( a: Matrix4, b: Matrix4 ): Matrix4;

    /**
      * Sets this matrix to a x b and stores the result into the flat array r.
      * r can be either a regular Array or a TypedArray.
      *
      * @deprecated This method has been removed completely.
      */
    multiplyToArray( a: Matrix4, b: Matrix4, r: number[] ): Matrix4;

    /**
      * Multiplies this matrix by s.
      */
    multiplyScalar( s: number ): Matrix4;

    /**
      * Computes determinant of this matrix.
      * Based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
      */
    determinant(): number;

    /**
      * Transposes this matrix.
      */
    transpose(): Matrix4;

    /**
      * Sets the position component for this matrix from vector v.
      */
    setPosition( v: Vector3 | number, y?: number, z?: number ): Matrix4;

    /**
      * Sets this matrix to the inverse of matrix m.
      * Based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm.
      */
    getInverse( m: Matrix4 ): Matrix4;

    /**
      * Multiplies the columns of this matrix by vector v.
      */
    scale( v: Vector3 ): Matrix4;

    getMaxScaleOnAxis(): number;
    /**
      * Sets this matrix as translation transform.
      */
    makeTranslation( x: number, y: number, z: number ): Matrix4;

    /**
      * Sets this matrix as rotation transform around x axis by theta radians.
      *
      * @param theta Rotation angle in radians.
      */
    makeRotationX( theta: number ): Matrix4;

    /**
      * Sets this matrix as rotation transform around y axis by theta radians.
      *
      * @param theta Rotation angle in radians.
      */
    makeRotationY( theta: number ): Matrix4;

    /**
      * Sets this matrix as rotation transform around z axis by theta radians.
      *
      * @param theta Rotation angle in radians.
      */
    makeRotationZ( theta: number ): Matrix4;

    /**
      * Sets this matrix as rotation transform around axis by angle radians.
      * Based on http://www.gamedev.net/reference/articles/article1199.asp.
      *
      * @param axis Rotation axis.
      * @param theta Rotation angle in radians.
      */
    makeRotationAxis( axis: Vector3, angle: number ): Matrix4;

    /**
      * Sets this matrix as scale transform.
      */
    makeScale( x: number, y: number, z: number ): Matrix4;

    /**
      * Sets this matrix to the transformation composed of translation, rotation and scale.
      */
    compose( translation: Vector3, rotation: Quaternion, scale: Vector3 ): Matrix4;

    /**
      * Decomposes this matrix into it's position, quaternion and scale components.
      */
    decompose(
        translation: Vector3,
        rotation: Quaternion,
        scale: Vector3
    ): Matrix4;

    /**
      * Creates a frustum matrix.
      */
    makePerspective(
        left: number,
        right: number,
        bottom: number,
        top: number,
        near: number,
        far: number
    ): Matrix4;

    /**
      * Creates a perspective projection matrix.
      */
    makePerspective(
        fov: number,
        aspect: number,
        near: number,
        far: number
    ): Matrix4;

    /**
      * Creates an orthographic projection matrix.
      */
    makeOrthographic(
        left: number,
        right: number,
        top: number,
        bottom: number,
        near: number,
        far: number
    ): Matrix4;
    equals( matrix: Matrix4 ): boolean;

    /**
      * Sets the values of this matrix from the provided array.
      * @param array the source array.
      * @param offset (optional) offset into the array. Default is 0.
      */
    fromArray( array: number[], offset?: number ): Matrix4;

    /**
      * Sets the values of this matrix from the provided array-like.
      * @param array the source array-like.
      * @param offset (optional) offset into the array-like. Default is 0.
      */
    fromArray( array: ArrayLike<number>, offset?: number ): Matrix4;

    /**
      * Returns an array with the values of this matrix, or copies them into the provided array.
      * @param array (optional) array to store the matrix to. If this is not provided, a new array will be created.
      * @param offset (optional) optional offset into the array.
      * @return The created or provided array.
      */
    toArray( array?: number[], offset?: number ): number[];

    /**
      * Copies he values of this matrix into the provided array-like.
      * @param array array-like to store the matrix to.
      * @param offset (optional) optional offset into the array-like.
      * @return The provided array-like.
      */
    toArray( array?: ArrayLike<number>, offset?: number ): ArrayLike<number>;

    /**
      * @deprecated Use {@link Matrix4#copyPosition .copyPosition()} instead.
      */
    extractPosition( m: Matrix4 ): Matrix4;

    /**
      * @deprecated Use {@link Matrix4#makeRotationFromQuaternion .makeRotationFromQuaternion()} instead.
      */
    setRotationFromQuaternion( q: Quaternion ): Matrix4;

    /**
      * @deprecated Use {@link Vector3#applyMatrix4 vector.applyMatrix4( matrix )} instead.
      */
    multiplyVector3( v: any ): any;

    /**
      * @deprecated Use {@link Vector4#applyMatrix4 vector.applyMatrix4( matrix )} instead.
      */
    multiplyVector4( v: any ): any;

    /**
      * @deprecated This method has been removed completely.
      */
    multiplyVector3Array( array: number[] ): number[];

    /**
      * @deprecated Use {@link Vector3#transformDirection Vector3.transformDirection( matrix )} instead.
      */
    rotateAxis( v: any ): void;

    /**
      * @deprecated Use {@link Vector3#applyMatrix4 vector.applyMatrix4( matrix )} instead.
      */
    crossVector( v: any ): void;

    /**
      * @deprecated Use {@link Matrix4#toArray .toArray()} instead.
      */
    flattenToArrayOffset( array: number[], offset: number ): number[];

}


/**
  * Implementation of a quaternion. This is used for rotating things without incurring in the dreaded gimbal lock issue, amongst other advantages.
  *
  * @example
  * const quaternion = new THREE.Quaternion();
  * quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Math.PI / 2 );
  * const vector = new THREE.Vector3( 1, 0, 0 );
  * vector.applyQuaternion( quaternion );
  */
export class Quaternion {

    /**
      * @param x x coordinate
      * @param y y coordinate
      * @param z z coordinate
      * @param w w coordinate
      */
    constructor( x?: number, y?: number, z?: number, w?: number );

    /**
      * @default 0
      */
    x: number;

    /**
      * @default 0
      */
    y: number;

    /**
      * @default 0
      */
    z: number;

    /**
      * @default 1
      */
    w: number;
    readonly isQuaternion: true;

    /**
      * Sets values of this quaternion.
      */
    set( x: number, y: number, z: number, w: number ): Quaternion;

    /**
      * Clones this quaternion.
      */
    clone(): this;

    /**
      * Copies values of q to this quaternion.
      */
    copy( q: Quaternion ): this;

    /**
      * Sets this quaternion from rotation specified by Euler angles.
      */
    setFromEuler( euler: Euler ): Quaternion;

    /**
      * Sets this quaternion from rotation specified by axis and angle.
      * Adapted from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm.
      * Axis have to be normalized, angle is in radians.
      */
    setFromAxisAngle( axis: Vector3, angle: number ): Quaternion;

    /**
      * Sets this quaternion from rotation component of m. Adapted from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm.
      */
    setFromRotationMatrix( m: Matrix4 ): Quaternion;
    setFromUnitVectors( vFrom: Vector3, vTo: Vector3 ): Quaternion;
    angleTo( q: Quaternion ): number;
    rotateTowards( q: Quaternion, step: number ): Quaternion;

    identity(): Quaternion;

    /**
      * Inverts this quaternion.
      */
    inverse(): Quaternion;

    conjugate(): Quaternion;
    dot( v: Quaternion ): number;
    lengthSq(): number;

    /**
      * Computes length of this quaternion.
      */
    length(): number;

    /**
      * Normalizes this quaternion.
      */
    normalize(): Quaternion;

    /**
      * Multiplies this quaternion by b.
      */
    multiply( q: Quaternion ): Quaternion;
    premultiply( q: Quaternion ): Quaternion;

    /**
      * Sets this quaternion to a x b
      * Adapted from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm.
      */
    multiplyQuaternions( a: Quaternion, b: Quaternion ): Quaternion;

    slerp( qb: Quaternion, t: number ): Quaternion;
    equals( v: Quaternion ): boolean;

    /**
      * Sets this quaternion's x, y, z and w value from the provided array.
      * @param array the source array.
      * @param offset (optional) offset into the array. Default is 0.
      */
    fromArray( array: number[], offset?: number ): this;

    /**
      * Sets this quaternion's x, y, z and w value from the provided array-like.
      * @param array the source array-like.
      * @param offset (optional) offset into the array-like. Default is 0.
      */
    fromArray( array: ArrayLike<number>, offset?: number ): this;

    /**
      * Returns an array [x, y, z, w], or copies x, y, z and w into the provided array.
      * @param array (optional) array to store the quaternion to. If this is not provided, a new array will be created.
      * @param offset (optional) optional offset into the array.
      * @return The created or provided array.
      */
    toArray( array?: number[], offset?: number ): number[];

    /**
      * Copies x, y, z and w into the provided array-like.
      * @param array array-like to store the quaternion to.
      * @param offset (optional) optional offset into the array.
      * @return The provided array-like.
      */
    toArray( array: ArrayLike<number>, offset?: number ): ArrayLike<number>;

    _onChange( callback: Function ): Quaternion;
    _onChangeCallback: Function;

    /**
      * Adapted from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/.
      */
    static slerp(
        qa: Quaternion,
        qb: Quaternion,
        qm: Quaternion,
        t: number
    ): Quaternion;

    static slerpFlat(
        dst: number[],
        dstOffset: number,
        src0: number[],
        srcOffset: number,
        src1: number[],
        stcOffset1: number,
        t: number
    ): Quaternion;

    static multiplyQuaternionsFlat(
        dst: number[],
        dstOffset: number,
        src0: number[],
        srcOffset: number,
        src1: number[],
        stcOffset1: number
    ): number[];

    /**
      * @deprecated Use {@link Vector#applyQuaternion vector.applyQuaternion( quaternion )} instead.
      */
    multiplyVector3( v: any ): any;

}


export class Spherical {

    constructor( radius?: number, phi?: number, theta?: number );

    /**
      * @default 1
      */
    radius: number;

    /**
      * @default 0
      */
    phi: number;

    /**
      * @default 0
      */
    theta: number;

    set( radius: number, phi: number, theta: number ): this;
    clone(): this;
    copy( other: Spherical ): this;
    makeSafe(): this;
    setFromVector3( v: Vector3 ): this;
    setFromCartesianCoords( x: number, y: number, z: number ): this;

}


export class Cylindrical {

    constructor( radius?: number, theta?: number, y?: number );

    /**
      * @default 1
      */
    radius: number;

    /**
      * @default 0
      */
    theta: number;

    /**
      * @default 0
      */
    y: number;

    clone(): this;
    copy( other: Cylindrical ): this;
    set( radius: number, theta: number, y: number ): this;
    setFromVector3( vec3: Vector3 ): this;
    setFromCartesianCoords( x: number, y: number, z: number ): this;

}

