<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - benchmark test</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #fff;
				color: #000;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>

	<body>
		<script src="../build/three.js"></script>

		<script src="js/vr/WebVR.js"></script>
		<script src="js/Detector.js"></script>

		<script>

			function FakeGL( gl ) {

				this.gl = gl;

				for ( var key in gl ) {

					if ( typeof gl[ key ] !== 'function' ) {

						this[ key ] = gl[ key ];

					}

				}

			}

			Object.assign( FakeGL.prototype, {

				getParameter: function () {

					return this.gl.getParameter.apply( this.gl, arguments );

				},

				getExtension: function () {

					return this.gl.getExtension.apply( this.gl, arguments );

				},

				createTexture: function () {

					return null;

				},

				bindTexture: function () {

					return null;

				},

				texParameteri: function () {

					return null;

				},

				texImage2D: function () {

					return null;

				},

				clearColor: function () {

					return null;

				},

				clearDepth: function () {

					return null;

				},

				clearStencil: function () {

					return null;

				},

				enable: function () {

					return null;

				},

				depthFunc: function () {

					return null;

				},

				frontFace: function () {

					return null;

				},

				cullFace: function () {

					return null;

				},

				scissor: function () {

					return null;

				},

				viewport: function () {

					return null;

				},

				createBuffer: function () {

					return null;

				},

				bindBuffer: function () {

					return null;

				},

				bufferData: function () {

					return null;

				},

				disable: function () {

					return null;

				},

				clear: function () {

					// Seems like this is necessary for FxR
					return this.gl.clear.apply( this.gl, arguments );

				},

				depthMask: function () {

					return null;

				},

				colorMask: function () {

					return null;

				},

				createProgram: function () {

					return null;

				},

				createShader: function () {

					return null;

				},

				shaderSource: function () {

					return null;

				},

				compileShader: function () {

					return null;

				},

				getShaderParameter: function () {

					return null;

				},

				getShaderInfoLog: function () {

					return '';

				},

				attachShader: function () {

					return null;

				},

				linkProgram: function () {

					return null;

				},

				getProgramInfoLog: function () {

					return '';

				},

				getProgramParameter: function () {

					return null;

				},

				deleteShader: function () {

					return null;

				},

				drawElements: function () {

					return null;

				}

			} );


		</script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container;
			var camera, scene, renderer;

			var container2;

			var gl;
			var buffers = [];
			var bufferIndex = 0;

			var meshes = [];

			var isPresenting = false;

			var objectNum = 100;
			var segmentNum = 1;
			var webGLEnabled = true;
			var sampleOnlyInVRMode = false;
			var targetIsFrame = false;

			var previousBeforeRender;
			var previousAfterRender;

			var params = location.href.split( '?' );

			if ( params.length > 1 ) {

				params = params.pop().split( '&' );

				for ( var i = 0, il = params.length; i < il; i ++ ) {

					var param = params[ i ].split( '=' );

					if ( param.length !== 2 ) {

						console.warn( 'Unknown Parameter: ', params[ i ] );
						continue;

					}

					switch ( param[ 0 ].toLowerCase() ) {

						case 'num':

							var num = parseInt( param[ 1 ] );

							if ( ! isNaN( num ) ) {

								objectNum = num;

							} else {

								console.warn( 'num value can not be parsed as Integer', param[ 1 ] );

							}

							break;

						case 'segment':

							var num = parseInt( param[ 1 ] );

							if ( ! isNaN( num ) ) {

								segmentNum = num;

							} else {

								console.warn( 'segment value can not be parsed as Integer', param[ 1 ] );

							}

							break;

						case 'webgl':

							var enabled = param[ 1 ].toLowerCase();

							if ( enabled === 'on' || enabled === 'off' ) {

								webGLEnabled = enabled === 'on';

							} else {

								console.warn( 'webgl value should be on or off.' );

							}

							break;

						case 'sample':

							var mode = param[ 1 ].toLowerCase();

							if ( mode === 'all' || mode === 'vr' ) {

								sampleOnlyInVRMode = mode === 'vr';

							} else {

								console.warn( 'sample value should be all or vr.' );

							}

							break;

						case 'target':

							var mode = param[ 1 ].toLowerCase();

							if ( mode === 'render' || mode === 'frame' ) {

								targetIsFrame = mode === 'frame';

							} else {

								console.warn( 'timing value should be render or frame.' );

							}

							break;

						default:

							console.warn( 'Unknown parameter key:', param[ 0 ] );
							break;

					}

				}

			}

			console.log( 'Object Num is', objectNum );
			console.log( 'Segment Num is', segmentNum );
			console.log( 'WebGL is', webGLEnabled === true ? 'on' : 'off' );
			console.log( 'Sampling mode is', sampleOnlyInVRMode === true ? 'vr' : 'all' );
			console.log( 'Sampling target is', targetIsFrame === true ? 'frame' : 'render' );

			var count = 0;
			var count2 = 0;
			var elapsedTime = 0.0;
			var minElapsedTime = 0.0;
			var maxElapsedTime = 0.0;
			var avgElapsedTime = 0.0;
			var totalElapsedTime = 0.0;

			init();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				// objects

				var material = new THREE.MeshBasicMaterial();

				for ( var i = 0; i < objectNum; i ++ ) {

					var mesh = new THREE.Mesh( createGeometry( i ), material );
					meshes.push( mesh );

				}

				var canvas = document.createElement( 'canvas' );
				var context = canvas.getContext( 'webgl' );

				if ( webGLEnabled === false ) context = new FakeGL( context );

				gl = context;

				for ( var i = 0; i < objectNum; i ++ ) {

					var mesh = meshes[ i ];

					var buffer = gl.createBuffer();
					mesh.userData.buffer = buffer;

				}

				container2 = document.createElement( 'div' );
				container2.style.position = 'fixed';
				container2.style.top = '0px';
				container2.style.right = '0px';
				container2.style.zIndex = '10000';
				container.appendChild( container2 );

				container2.appendChild( document.createTextNode( 'Elapsed' + ( targetIsFrame ? '' : '.render() CPU' ) + ' time [ms] / 60 frames' ) );
				container2.appendChild( document.createElement( 'br' ) );
				container2.appendChild( document.createTextNode( '0' ) );
				container2.appendChild( document.createElement( 'br' ) );
				container2.appendChild( document.createTextNode( 'min / max / avg / count' ) );
				container2.appendChild( document.createElement( 'br' ) );
				container2.appendChild( document.createTextNode( '0' ) );
				container2.appendChild( document.createTextNode( ' / ' ) );
				container2.appendChild( document.createTextNode( '0' ) );
				container2.appendChild( document.createTextNode( ' / ' ) );
				container2.appendChild( document.createTextNode( '0' ) );
				container2.appendChild( document.createTextNode( ' / ' ) );
				container2.appendChild( document.createTextNode( '0' ) );

				animate();

			}

			function createGeometry( id ) {

				switch( id % 6 ) {

					case 0:

						return new THREE.BoxBufferGeometry( 0.1, 0.1, 0.1, segmentNum, segmentNum, segmentNum );

					case 1:

						return new THREE.SphereBufferGeometry( 0.1, segmentNum, segmentNum );

					case 2:

						return new THREE.CircleBufferGeometry( 0.1, segmentNum * 12 );

					case 3:

						return new THREE.ConeBufferGeometry( 0.1, 0.1, segmentNum * 8, segmentNum );

					case 4:

						return new THREE.CylinderBufferGeometry( 0.1, 0.1, 0.1, segmentNum * 8, segmentNum );

					case 5:

						return new THREE.PlaneBufferGeometry( 0.1, 0.1, segmentNum, segmentNum );

				}

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				var beforeRenderTime = performance.now();

				process();

				var afterRenderTime = performance.now();

				var startTime;
				var endTime;

				if ( targetIsFrame ) {

					startTime = previousBeforeRender;
					endTime = beforeRenderTime;

				} else {

					startTime = beforeRenderTime;
					endTime = afterRenderTime;

				}

				elapsedTime += ( endTime - startTime );

				previousBeforeRender = beforeRenderTime;
				previousAfterRender = afterRenderTime;

				if ( ( ! sampleOnlyInVRMode || isPresenting ) && ++ count === 60 ) {

					count2 ++;

					// ignore first ten for min/max/avg

					if ( count2 > 10 ) {

						minElapsedTime = minElapsedTime === 0.0 ? elapsedTime : Math.min( elapsedTime, minElapsedTime );
						maxElapsedTime = Math.max( elapsedTime, maxElapsedTime );
						totalElapsedTime += elapsedTime;

					}

					container2.childNodes[ 2 ].textContent = elapsedTime.toFixed( 2 );
					container2.childNodes[ 6 ].textContent = minElapsedTime.toFixed( 2 );
					container2.childNodes[ 8 ].textContent = maxElapsedTime.toFixed( 2 );
					container2.childNodes[ 10 ].textContent = ( totalElapsedTime / ( count2 - 10 ) ).toFixed( 2 );
					container2.childNodes[ 12 ].textContent = count2 - 10;

					elapsedTime = 0.0;
					count = 0;

				}

			}

			function process() {

				for ( var i = 0; i < objectNum; i ++ ) {

					var mesh = meshes[ i ];
					var buffer = mesh.userData.buffer;

					gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

				}

			}
		</script>

	</body>
</html>
